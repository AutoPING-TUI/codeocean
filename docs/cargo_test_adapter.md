# The Cargo Test Adapter
This documentation focusses on the file `lib/cargo_test_adapter.rb`. It only explains the functions `parse_json_objects_per_line(string)` and `extract_test_result_parameters(parsed_json_objects)`. For more details on `self.framework_name` and `parse_output(output)` see [add_new_programming_language.md](add_new_programming_language.md).

The code assumes that the JSON output was generated by Cargo version 1.59.0 with the command `cargo test --no-fail-fast -q --color never --message-format json-diagnostic-short -- --color never -Z unstable-options --format json`. Note that the [json output format for tests is unstable](https://doc.rust-lang.org/rustc/tests/index.html#--format-format) and might change with newer Rust and Cargo versions. If that happens the code must be updated.

## Example project
Let us look at a Rust project consisting of three files:

`Cargo.toml`:
```
[package]
name = "add"
version = "0.1.0"
edition = "2021"

[dependencies]
```

`src/main.rs`:
```rust
fn main() { println!("Hello, world!"); }

fn add(a: i32, b: i32) -> i32 { a }

fn mult(a: i32, b: i32) -> i32 { a }

#[cfg(test)]
mod tests;
```

`src/tests.rs`:
```rust
use super::*;

#[test]
fn test_add() {
    assert_eq!(add(1,1), 2);
}

#[test]
fn test_mutl() {
    assert_eq!(mult(1,0), 0);
    assert_eq!(mult(1,1), 1);
    assert_eq!(mult(-1,1), -1);
    assert_eq!(mult(1,-1), -1);
    assert_eq!(mult(-1,-1), 1);
}
```

The output generated by our test command inside Codeocean will look like this (the compiler messages are left out because they are not needed):

```json
[...]
{"reason":"build-finished","success":true}
{ "type": "suite", "event": "started", "test_count": 2 }
{ "type": "test", "event": "started", "name": "tests::test_add" }
{ "type": "test", "event": "started", "name": "tests::test_mutl" }
{ "type": "test", "name": "tests::test_mutl", "event": "failed", "stdout": "thread 'tests::test_mutl' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `0`', src/tests.rs:10:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n" }
{ "type": "test", "name": "tests::test_add", "event": "failed", "stdout": "thread 'tests::test_add' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `2`', src/tests.rs:5:5\n" }
{ "type": "suite", "event": "failed", "passed": 0, "failed": 2, "allowed_fail": 0, "ignored": 0, "measured": 0, "filtered_out": 0, "exec_time": 0.000608784 }
error: test failed, to rerun pass '--bin add'
```

We see that each line contains either a valid JSON object or some text. In `parse_json_objects_per_line(string)` we therefore iterate over each line, parse it and if it is valid JSON push it into an array. If it is not a JSON object, we skip the line. 

The array is then passed to `extract_test_result_parameters`. In here we first find out if the compilation was successful by finding the JSON object with the key-value pair `"reason" : "build-finished"` and accessing the value of the `"success"` key. If compilation was successful, we count the number of tests performed, the number of tests that failed and collect all error messages. The `count` and `failed` variables are updated with `+=` because there may be multiple JSON objects that match the `"type" : "suite"` key-value pairs and have either the `"test_count"` or `"failed"` keys. This happens, for example, when there are unit tests and integration tests in the same project.
